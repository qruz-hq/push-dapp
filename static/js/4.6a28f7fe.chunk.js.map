{"version":3,"file":"static/js/4.6a28f7fe.chunk.js","mappings":"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","sources":["../node_modules/openpgp/node_modules/@openpgp/web-stream-tools/node_modules/web-streams-polyfill/dist/ponyfill.es6.mjs"],"sourcesContent":["/**\n * web-streams-polyfill v3.0.3\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    return undefined;\n}\nfunction getGlobals() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        return global;\n    }\n    return undefined;\n}\nconst globals = getGlobals();\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nconst rethrowAssertionErrorRejection = noop;\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\nconst queueMicrotask = (() => {\n    const globalQueueMicrotask = globals && globals.queueMicrotask;\n    if (typeof globalQueueMicrotask === 'function') {\n        return globalQueueMicrotask;\n    }\n    const resolvedPromise = promiseResolvedWith(undefined);\n    return (fn) => PerformPromiseThen(resolvedPromise, fn);\n})();\nfunction reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction promiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(reflectCall(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n        return;\n    }\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n};\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nfunction isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n}\nfunction assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-callback-functions\nfunction assertFunction(x, context) {\n    if (typeof x !== 'function') {\n        throw new TypeError(`${context} is not a function.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-object\nfunction isObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction assertObject(x, context) {\n    if (!isObject(x)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\nfunction assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n        throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n    }\n}\nfunction assertRequiredField(x, field, context) {\n    if (x === undefined) {\n        throw new TypeError(`${field} is required in '${context}'.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nfunction convertUnrestrictedDouble(value) {\n    return Number(value);\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n}\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nfunction convertUnsignedLongLongWithEnforceRange(value, context) {\n    const lowerBound = 0;\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    let x = Number(value);\n    x = censorNegativeZero(x);\n    if (!NumberIsFinite(x)) {\n        throw new TypeError(`${context} is not a finite number`);\n    }\n    x = integerPart(x);\n    if (x < lowerBound || x > upperBound) {\n        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n    }\n    if (!NumberIsFinite(x) || x === 0) {\n        return 0;\n    }\n    // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n    return x;\n}\n\nfunction assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n        throw new TypeError(`${context} is not a ReadableStream.`);\n    }\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    if (done) {\n        readRequest._closeSteps();\n    }\n    else {\n        readRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader, readRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        readRequest._closeSteps();\n    }\n    else if (stream._state === 'errored') {\n        readRequest._errorSteps(stream._storedError);\n    }\n    else {\n        stream._readableStreamController[PullSteps](readRequest);\n    }\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nlet AsyncIteratorPrototype;\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    // We're running inside a ES2018+ environment, but we're compiling to an older syntax.\n    // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.\n    AsyncIteratorPrototype = {\n        // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )\n        // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator\n        [SymbolPolyfill.asyncIterator]() {\n            return this;\n        }\n    };\n    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nclass ReadableStreamAsyncIteratorImpl {\n    constructor(reader, preventCancel) {\n        this._ongoingPromise = undefined;\n        this._isFinished = false;\n        this._reader = reader;\n        this._preventCancel = preventCancel;\n    }\n    next() {\n        const nextSteps = () => this._nextSteps();\n        this._ongoingPromise = this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n            nextSteps();\n        return this._ongoingPromise;\n    }\n    return(value) {\n        const returnSteps = () => this._returnSteps(value);\n        return this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n            returnSteps();\n    }\n    _nextSteps() {\n        if (this._isFinished) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => {\n                this._ongoingPromise = undefined;\n                // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                // FIXME Is this a bug in the specification, or in the test?\n                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                resolvePromise({ value: undefined, done: true });\n            },\n            _errorSteps: reason => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                rejectPromise(reason);\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n    }\n    _returnSteps(value) {\n        if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n        }\n        this._isFinished = true;\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({ value, done: true });\n    }\n}\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        return this._asyncIteratorImpl.next();\n    },\n    return(value) {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n        }\n        return this._asyncIteratorImpl.return(value);\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n        return false;\n    }\n    return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nfunction IsFiniteNonNegativeNumber(v) {\n    if (!IsNonNegativeNumber(v)) {\n        return false;\n    }\n    if (v === Infinity) {\n        return false;\n    }\n    return true;\n}\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    size = Number(size);\n    if (!IsFiniteNonNegativeNumber(size)) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\nfunction CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n    return false;\n}\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nclass ReadableStreamBYOBRequest {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respondWithNewView');\n        }\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (view.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (view.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: { enumerable: true },\n    respondWithNewView: { enumerable: true },\n    view: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBRequest',\n        configurable: true\n    });\n}\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableByteStreamController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        if (this._byobRequest === null && this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n            this._byobRequest = byobRequest;\n        }\n        return this._byobRequest;\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        assertRequiredArgument(chunk, 1, 'enqueue');\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('chunk must be an array buffer view');\n        }\n        if (chunk.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._closeRequested) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        if (this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            firstDescriptor.bytesFilled = 0;\n        }\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                readRequest._errorSteps(bufferE);\n                return;\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n    }\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    byobRequest: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableByteStreamController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    const buffer = TransferArrayBuffer(view.buffer);\n    const pullIntoDescriptor = {\n        buffer,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        viewConstructor: ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        return;\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        readIntoRequest._closeSteps(emptyView);\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n        }\n        if (controller._closeRequested) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream)) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n    }\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        // TODO: Figure out whether we should detach the buffer or not here.\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (ReadableStreamHasDefaultReader(stream)) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream)) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    bytesWritten = Number(bytesWritten);\n    if (!IsFiniteNonNegativeNumber(bytesWritten)) {\n        throw new RangeError('bytesWritten must be a finite');\n    }\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.byteLength !== view.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    firstDescriptor.buffer = view.buffer;\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingByteSource.start !== undefined) {\n        startAlgorithm = () => underlyingByteSource.start(controller);\n    }\n    if (underlyingByteSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingByteSource.pull(controller);\n    }\n    if (underlyingByteSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n    }\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize === 0) {\n        throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    if (done) {\n        readIntoRequest._closeSteps(chunk);\n    }\n    else {\n        readIntoRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readIntoRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        readIntoRequest._errorSteps(stream._storedError);\n    }\n    else {\n        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nfunction ExtractHighWaterMark(strategy, defaultHWM) {\n    const { highWaterMark } = strategy;\n    if (highWaterMark === undefined) {\n        return defaultHWM;\n    }\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('Invalid highWaterMark');\n    }\n    return highWaterMark;\n}\nfunction ExtractSizeAlgorithm(strategy) {\n    const { size } = strategy;\n    if (!size) {\n        return () => 1;\n    }\n    return size;\n}\n\nfunction convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    const size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n    };\n}\nfunction convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n\nfunction convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    const abort = original === null || original === void 0 ? void 0 : original.abort;\n    const close = original === null || original === void 0 ? void 0 : original.close;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    const write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n        abort: abort === undefined ?\n            undefined :\n            convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n        close: close === undefined ?\n            undefined :\n            convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n        write: write === undefined ?\n            undefined :\n            convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n        type\n    };\n}\nfunction convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return () => promiseCall(fn, original, []);\n}\nfunction convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n        throw new TypeError(`${context} is not a WritableStream.`);\n    }\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream {\n    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n        if (rawUnderlyingSink === undefined) {\n            rawUnderlyingSink = null;\n        }\n        else {\n            assertObject(rawUnderlyingSink, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n        InitializeWritableStream(this);\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close() {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    getWriter: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStream',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (!wasAlreadyErroring) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n        assertWritableStream(stream, 'First parameter');\n        if (IsWritableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writers lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writers lock is released.\n     */\n    get desiredSize() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    /**\n     * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    releaseLock: { enumerable: true },\n    write: { enumerable: true },\n    closed: { enumerable: true },\n    desiredSize: { enumerable: true },\n    ready: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultWriter',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nconst closeSentinel = {};\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nclass WritableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e = undefined) {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    error: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let writeAlgorithm = () => promiseResolvedWith(undefined);\n    let closeAlgorithm = () => promiseResolvedWith(undefined);\n    let abortAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSink.start !== undefined) {\n        startAlgorithm = () => underlyingSink.start(controller);\n    }\n    if (underlyingSink.write !== undefined) {\n        writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n    }\n    if (underlyingSink.close !== undefined) {\n        closeAlgorithm = () => underlyingSink.close();\n    }\n    if (underlyingSink.abort !== undefined) {\n        abortAlgorithm = reason => underlyingSink.abort(reason);\n    }\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (!controller._started) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const value = PeekQueueValue(controller);\n    if (value === closeSentinel) {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n        return;\n    }\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n        return;\n    }\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\n// eslint-disable-next-line no-redeclare\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (!preventAbort) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (!preventCancel) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                        _chunkSteps: chunk => {\n                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                            resolveRead(false);\n                        },\n                        _closeSteps: () => resolveRead(true),\n                        _errorSteps: rejectRead\n                    });\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (!preventAbort) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('close');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n        }\n        else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n    }\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (!controller._closeRequested && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSource.start !== undefined) {\n        startAlgorithm = () => underlyingSource.start(controller);\n    }\n    if (underlyingSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingSource.pull(controller);\n    }\n    if (underlyingSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingSource.cancel(reason);\n    }\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading) {\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readRequest = {\n            _chunkSteps: value => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    reading = false;\n                    const value1 = value;\n                    const value2 = value;\n                    // There is no way to access the cloning code right now in the reference implementation.\n                    // If we add one then we'll need an implementation for serializable objects.\n                    // if (!canceled2 && cloneForBranch2) {\n                    //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n                    // }\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        // do nothing\n    }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n        if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n        }\n    });\n    return [branch1, branch2];\n}\n\nfunction convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    const original = source;\n    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    const pull = original === null || original === void 0 ? void 0 : original.pull;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n        autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n            undefined :\n            convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n        cancel: cancel === undefined ?\n            undefined :\n            convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n        pull: pull === undefined ?\n            undefined :\n            convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n    };\n}\nfunction convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertReadableStreamType(type, context) {\n    type = `${type}`;\n    if (type !== 'bytes') {\n        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n    }\n    return type;\n}\n\nfunction convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    const mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n    };\n}\nfunction convertReadableStreamReaderMode(mode, context) {\n    mode = `${mode}`;\n    if (mode !== 'byob') {\n        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    }\n    return mode;\n}\n\nfunction convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return { preventCancel: Boolean(preventCancel) };\n}\n\nfunction convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal !== undefined) {\n        assertAbortSignal(signal, `${context} has member 'signal' that`);\n    }\n    return {\n        preventAbort: Boolean(preventAbort),\n        preventCancel: Boolean(preventCancel),\n        preventClose: Boolean(preventClose),\n        signal\n    };\n}\nfunction assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n        throw new TypeError(`${context} is not an AbortSignal.`);\n    }\n}\n\nfunction convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, `${context} has member 'readable' that`);\n    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, `${context} has member 'writable' that`);\n    return { readable, writable };\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nclass ReadableStream {\n    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n        if (rawUnderlyingSource === undefined) {\n            rawUnderlyingSource = null;\n        }\n        else {\n            assertObject(rawUnderlyingSource, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n        InitializeReadableStream(this);\n        if (underlyingSource.type === 'bytes') {\n            if (strategy.size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        const options = convertReaderOptions(rawOptions, 'First parameter');\n        if (options.mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this);\n        }\n        return AcquireReadableStreamBYOBReader(this);\n    }\n    pipeThrough(rawTransform, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        const options = convertPipeOptions(rawOptions, 'Second parameter');\n        if (IsReadableStreamLocked(this)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n    }\n    pipeTo(destination, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (destination === undefined) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n        }\n        if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n        }\n        let options;\n        try {\n            options = convertPipeOptions(rawOptions, 'Second parameter');\n        }\n        catch (e) {\n            return promiseRejectedWith(e);\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n    }\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n    }\n    values(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('values');\n        }\n        const options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n    }\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: { enumerable: true },\n    getReader: { enumerable: true },\n    pipeThrough: { enumerable: true },\n    pipeTo: { enumerable: true },\n    tee: { enumerable: true },\n    values: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStream',\n        configurable: true\n    });\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.values,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseResolve(reader);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._closeSteps();\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._errorSteps(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._errorSteps(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nfunction convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n        highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n}\n\nconst byteLengthSizeFunction = function size(chunk) {\n    return chunk.byteLength;\n};\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nclass ByteLengthQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('highWaterMark');\n        }\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('size');\n        }\n        return byteLengthSizeFunction;\n    }\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ByteLengthQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the ByteLengthQueuingStrategy.\nfunction byteLengthBrandCheckException(name) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nconst countSizeFunction = function size() {\n    return 1;\n};\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nclass CountQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('highWaterMark');\n        }\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('size');\n        }\n        return countSizeFunction;\n    }\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'CountQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the CountQueuingStrategy.\nfunction countBrandCheckException(name) {\n    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\nfunction IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nfunction convertTransformer(original, context) {\n    assertDictionary(original, context);\n    const flush = original === null || original === void 0 ? void 0 : original.flush;\n    const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const transform = original === null || original === void 0 ? void 0 : original.transform;\n    const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n        flush: flush === undefined ?\n            undefined :\n            convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n        readableType,\n        start: start === undefined ?\n            undefined :\n            convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n        transform: transform === undefined ?\n            undefined :\n            convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n        writableType\n    };\n}\nfunction convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\n// Class TransformStream\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nclass TransformStream {\n    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n        if (rawTransformer === undefined) {\n            rawTransformer = null;\n        }\n        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n        const transformer = convertTransformer(rawTransformer, 'First parameter');\n        if (transformer.readableType !== undefined) {\n            throw new RangeError('Invalid readableType specified');\n        }\n        if (transformer.writableType !== undefined) {\n            throw new RangeError('Invalid writableType specified');\n        }\n        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        if (transformer.start !== undefined) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n        }\n        else {\n            startPromise_resolve(undefined);\n        }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('readable');\n        }\n        return this._readable;\n    }\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('writable');\n        }\n        return this._writable;\n    }\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: { enumerable: true },\n    writable: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStream',\n        configurable: true\n    });\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\n// Class TransformStreamDefaultController\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nclass TransformStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    terminate: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStreamDefaultController',\n        configurable: true\n    });\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    let flushAlgorithm = () => promiseResolvedWith(undefined);\n    if (transformer.transform !== undefined) {\n        transformAlgorithm = chunk => transformer.transform(chunk, controller);\n    }\n    if (transformer.flush !== undefined) {\n        flushAlgorithm = () => transformer.flush(controller);\n    }\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter };\n//# sourceMappingURL=ponyfill.es6.mjs.map\n"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","globals","self","window","global","typeIsObject","x","rethrowAssertionErrorRejection","originalPromise","Promise","originalPromiseThen","prototype","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","promiseResolvedWith","value","promiseRejectedWith","reason","PerformPromiseThen","promise","onFulfilled","onRejected","call","uponPromise","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","queueMicrotask","globalQueueMicrotask","resolvedPromise","fn","reflectCall","F","V","args","TypeError","Function","apply","promiseCall","SimpleQueue","constructor","this","_cursor","_size","_front","_elements","_next","_back","length","push","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","shift","oldFront","newFront","oldCursor","newCursor","elements","forEach","callback","i","node","peek","front","cursor","ReadableStreamReaderGenericInitialize","reader","stream","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","AbortSteps","ErrorSteps","CancelSteps","PullSteps","NumberIsFinite","Number","isFinite","MathTrunc","Math","trunc","v","ceil","floor","assertDictionary","obj","context","assertFunction","assertObject","isObject","assertRequiredArgument","position","assertRequiredField","field","convertUnrestrictedDouble","censorNegativeZero","convertUnsignedLongLongWithEnforceRange","upperBound","MAX_SAFE_INTEGER","integerPart","assertReadableStream","IsReadableStream","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamFulfillReadRequest","chunk","done","_closeSteps","_chunkSteps","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","AsyncIteratorPrototype","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","cancel","read","resolvePromise","rejectPromise","ReadableStreamDefaultReaderRead","_errorSteps","e","releaseLock","Object","hasOwnProperty","_disturbed","_readableStreamController","defineProperties","enumerable","toStringTag","defineProperty","configurable","asyncIterator","ReadableStreamAsyncIteratorImpl","preventCancel","_ongoingPromise","_isFinished","_preventCancel","next","nextSteps","_nextSteps","return","returnSteps","_returnSteps","result","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","_asyncIteratorImpl","streamAsyncIteratorBrandCheckException","setPrototypeOf","NumberIsNaN","isNaN","IsFiniteNonNegativeNumber","IsNonNegativeNumber","Infinity","DequeueValue","container","pair","_queue","_queueTotalSize","size","EnqueueValueWithSize","RangeError","ResetQueue","CreateArrayFromList","slice","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","respond","bytesWritten","_associatedReadableByteStreamController","buffer","controller","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","respondWithNewView","ArrayBuffer","isView","byteLength","firstDescriptor","_pendingPullIntos","byteOffset","bytesFilled","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","_byobRequest","Uint8Array","create","request","SetUpReadableStreamBYOBRequest","desiredSize","ReadableByteStreamControllerGetDesiredSize","close","_closeRequested","state","_controlledReadableByteStream","ReadableByteStreamControllerError","ReadableByteStreamControllerClearAlgorithms","ReadableStreamClose","ReadableByteStreamControllerClose","enqueue","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableStreamHasBYOBReader","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerEnqueue","error","_cancelAlgorithm","entry","ReadableByteStreamControllerHandleQueueDrain","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","viewConstructor","readerType","_started","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","readIntoRequest","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","dest","destOffset","src","srcOffset","n","queue","headOfQueue","bytesToCopy","destStart","set","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","ReadableByteStreamControllerClearPendingPullIntos","ReadableStreamError","_strategyHWM","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","highWaterMark","startAlgorithm","pullAlgorithm","cancelAlgorithm","undefined","start","pull","r","SetUpReadableByteStreamController","ReadableStreamAddReadIntoRequest","IsReadableStreamBYOBReader","ReadableStreamBYOBReader","byobReaderBrandCheckException","DataView","BYTES_PER_ELEMENT","ctor","emptyView","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ExtractHighWaterMark","strategy","defaultHWM","ExtractSizeAlgorithm","convertQueuingStrategy","init","convertQueuingStrategySize","convertUnderlyingSinkAbortCallback","original","convertUnderlyingSinkCloseCallback","convertUnderlyingSinkStartCallback","convertUnderlyingSinkWriteCallback","assertWritableStream","IsWritableStream","WritableStream","rawUnderlyingSink","rawStrategy","underlyingSink","abort","type","write","convertUnderlyingSink","InitializeWritableStream","sizeAlgorithm","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","streamBrandCheckException$2","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","getWriter","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","closeSentinel","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","writeRequest","abortRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","WritableStreamDefaultWriterEnsureClosedPromiseRejected","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_writeAlgorithm","_closeAlgorithm","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","NativeDOMException","DOMException","DOMException$1","_a","isDOMExceptionConstructor","message","Error","captureStackTrace","writable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","preventClose","preventAbort","signal","shuttingDown","currentWrite","action","actions","shutdownWithAction","all","map","aborted","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","resolveRead","rejectRead","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException$1","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","ReadableStreamDefaultControllerShouldCallPull","SetUpReadableStreamDefaultController","convertUnderlyingSourceCancelCallback","convertUnderlyingSourcePullCallback","convertUnderlyingSourceStartCallback","convertReadableStreamType","convertReadableStreamReaderMode","mode","convertPipeOptions","options","isAbortSignal","assertAbortSignal","ReadableStream","rawUnderlyingSource","underlyingSource","convertUnderlyingDefaultOrByteSource","InitializeReadableStream","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","getReader","rawOptions","convertReaderOptions","pipeThrough","rawTransform","transform","readable","convertReadableWritablePair","pipeTo","destination","tee","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","canceled1","canceled2","cancelPromise","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","values","impl","AcquireReadableStreamAsyncIterator","convertIteratorOptions","convertQueuingStrategyInit","byteLengthSizeFunction","ByteLengthQueuingStrategy","_byteLengthQueuingStrategyHighWaterMark","IsByteLengthQueuingStrategy","byteLengthBrandCheckException","countSizeFunction","CountQueuingStrategy","_countQueuingStrategyHighWaterMark","IsCountQueuingStrategy","countBrandCheckException","convertTransformerFlushCallback","convertTransformerStartCallback","convertTransformerTransformCallback","TransformStream","rawTransformer","rawWritableStrategy","rawReadableStrategy","writableStrategy","readableStrategy","transformer","flush","readableType","writableType","convertTransformer","startPromise_resolve","readableHighWaterMark","readableSizeAlgorithm","writableHighWaterMark","writableSizeAlgorithm","startPromise","_writable","CreateWritableStream","_transformStreamController","_backpressureChangePromise","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","_readable","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","TransformStreamError","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise_resolve","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","flushAlgorithm","_controlledTransformStream","_transformAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","IsTransformStream","streamBrandCheckException","IsTransformStreamDefaultController","defaultControllerBrandCheckException","terminate","TransformStreamDefaultControllerTerminate","readableController"],"sourceRoot":""}